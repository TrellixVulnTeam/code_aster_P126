# coding=utf-8

import os.path as osp
import optparse
from functools import partial

from waflib import TaskGen, Configure, Logs, Utils, Errors

def _deprecated(option, *args, **kwargs):
    """Deprecated option"""
    Logs.warn("The option '{}' is not supported anymore.".format(option))

def options(self):
    self.load('compiler_c')
    # for backward compatibility
    group = self.get_option_group("Code_Aster options")
    deprecate = partial(group.add_option, action='callback',
                        callback=_deprecated, help=optparse.SUPPRESS_HELP)
    deprecate('-e', '--build-executable')
    deprecate('--embed-aster')
    deprecate('--shared-aster')

def configure(self):
    self.load('compiler_c')
    opts = self.options
    # preserve symbols in the dyn table for stdcalls
    self.env.append_unique('LINKFLAGS', ['-Wl,--export-dynamic'])

    self.check_swig_all()
    self.check_cython_includes()

    if 'ifort' in self.env.get_flat('LINK_FC'):
        self.env.append_value('LINKFLAGS_fcprogram', ['-nofor_main'])
    self.check_cflags()
    self.check_bibc_depends()

@Configure.conf
def check_swig_all(self):
    self.load('swig')
    if self.check_swig_version() < (1, 3, 0):
        self.fatal('this swig version is too old')
    self.check_swig_headers()

@Configure.conf
def check_cython_includes(self):
    cypath = osp.join(self.path.get_src().parent.abspath(), 'code_aster')
    self.env.append_unique('INCLUDES', cypath)

@Configure.conf
def check_bibc_depends(self):
    """check dependencies of bibc"""
    # never in static
    self.check_cc(uselib_store='SYS', lib='dl')
    self.check_code_aster_cython()

@Configure.conf
def check_code_aster_cython(self):
    # FIXME used while we are building the code_aster cython package with `setup.py`
    try:
        self.check_cc(uselib_store='CYTHON_EXT', lib='DataStructure')
        self.check_cc(uselib_store='CYTHON_EXT', lib='CommandSyntax')
        self.check_cc(uselib_store='CYTHON_EXT', lib='Initializer')
        self.define('HAVE_CYTHON', 1)
    except Errors.ConfigurationError:
        self.undefine('HAVE_CYTHON')

PYMAIN = 'supervis/python.c'

def build(self):
    # The build is splitted in 3 stages:
    # - compilation of C source files
    # - link of the executable (embedded) or several shared libs (shared)
    # - build and link the swig wrapper
    #
    get_srcs = self.path.get_src().ant_glob
    env = self.all_envs[self.variant]
    excl = [] if env.BUILD_MED else ['**/med_aster_module.c']

    build_c_source(self, env, excl)
    build_libaster(self, env)
    build_module(self, env)

    self.add_group()
    # install headers
    self.install_files(
        env.ASTERINCLUDEDIR,
        get_srcs('include/*.h')
    )
    # install generated headers (C + fortran)
    bld = self.path.get_bld().parent
    config_includes = bld.ant_glob('aster*_config.h', quiet=True)
    self.install_files(
        env.ASTERINCLUDEDIR,
        config_includes
    )

@TaskGen.extension('.h')
def process_h(self, node):
    pass

def build_c_source(self, env, excl):
    get_srcs = self.path.get_src().ant_glob
    uses = env['all_dependencies'] + ['CYTHON_EXT']    # XXX: required ?
    # compile *.c
    self(
        features = 'c',
            name = 'asterbibc',
          source = get_srcs('**/*.c', excl=excl + [PYMAIN]),
         defines = '',
             env = env.derive(),
             use = ['PYEMBED', 'NUMPY'] + uses,
    )

def build_libaster(self, shenv):
    get_srcs = self.path.get_src().ant_glob
    uses = shenv['all_dependencies']    # XXX: required CYTHON_EXT ?
    # {bibfor, bibc, bibcxx}/*.o
    self(
        features = 'cxx cxxshlib',
            name = 'asterlib',
          target = 'aster',
          source = PYMAIN,
         defines = '_MAIN_=_unused_main_', #'_WITHOUT_PYMOD_',
             env = shenv.derive(),
             use = ['PYEMBED', 'NUMPY', 'asterbibfor',
                    'asterbibc', 'asterbibcxx'] + uses + ['CXX'],
    install_path = shenv.ASTERLIBDIR,
    )

def build_module(self, env):
    uses = env['all_dependencies'] + ['CYTHON_EXT']    # XXX: required ?
    self(
        features = 'cxx cxxshlib pyext',
            name = 'asterswig',
          source = '../bibcxx/code_aster.i',
          target = '_code_aster',
      swig_flags = '-c++ -python -Wall',
             env = env.derive(),
             use = ['asterlib'] + uses,
    install_path = env.ASTERLIBDIR,
    )
    node = self.path.get_bld().find_or_declare('../bibcxx/code_aster.py')
    # because .py must exist before installing
    self.add_group()
    self.install_files(env.ASTERLIBDIR, node)


###############################################################################
@Configure.conf
def check_cflags(self):
    self.start_msg('Getting C compiler flags')
    if 'icc' in self.env.CC_NAME:
        self.safe_remove('CFLAGS_PYEXT', '-fwrapv')
        self.safe_remove('CFLAGS_PYEMBED', '-fwrapv')
        self.safe_remove('CXXFLAGS_PYEXT', '-fwrapv')
        self.safe_remove('CXXFLAGS_PYEMBED', '-fwrapv')
    self.end_msg(self.env['CFLAGS'])

@Configure.conf
def check_optimization_cflags(self):
    self.setenv('debug')
    flags = ['-g'] + Utils.to_list(self.env['CFLAGS_ASTER_DEBUG'])
    self.start_msg('Setting C debug flags')
    self.env.append_unique('CFLAGS', flags)
    self.end_msg(flags)

    self.setenv('release')
    flags = ['-O2']
    self.start_msg('Setting C optimization flags')
    self.env.append_unique('CFLAGS', flags)
    self.end_msg(flags)

SWIG_FRAGMENT = """
%%module testswig
%%{
%%}

%%include "%s"
"""

@Configure.conf
def check_swig(self, *k, **kw):
    """Override :py:func:`waflib.Tools.c_config.check_cxx` using features for swig"""
    def error(*k, **kw):
        Logs.error(*k, **kw)
        raise Errors.ConfigurationError(*k, **kw)
    kw['features'] = 'cxx cxxshlib pyext'
    kw['swig_flags'] = ('-c++', '-python', '-Wall')
    kw['compile_filename'] = 'testswig.i'
    if not 'fragment' in kw and 'header_name' in kw:
        kw['fragment'] = SWIG_FRAGMENT % kw['header_name']
    # force swig to fail if an include is not found
    _warn = Logs.warn
    Logs.warn = error
    ret = self.check(*k, **kw)
    Logs.warn = _warn
    return ret

@Configure.conf
def check_swig_headers(self):
    """Check for required swig headers"""
    self.start_msg('Checking for swig includes path')
    swig_out = self.cmd_and_log('%s -swiglib' % self.env['SWIG'])
    if swig_out:
        incpath = osp.join(swig_out.strip(), 'python')
        self.env.append_value('INCLUDES_SWIG', incpath)
    else:
        incpath = '-'
    self.end_msg(incpath)

    self.check_swig(header_name='exception.i',
                    uselib_store='SWIG', use='SWIG CXX', mandatory=True)
