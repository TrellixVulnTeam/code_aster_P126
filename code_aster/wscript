# coding=utf-8

# Copyright (C) 1991 - 2015  EDF R&D                www.code-aster.org
#
# This file is part of Code_Aster.
#
# Code_Aster is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# Code_Aster is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Code_Aster.  If not, see <http://www.gnu.org/licenses/>.

import os
import os.path as osp

from waflib import TaskGen, Task, Configure, Logs, Utils, Errors, Context


def options(self):
    self.load('cython')

def configure(self):
    self.load('cython')
    self.start_msg('Checking for Cython version')
    output = self.cmd_and_log([self.env['CYTHON'], '--version'], output=Context.STDERR)
    self.end_msg(output.strip())

def build(self):
    get_srcs = self.path.get_src().ant_glob
    env = self.all_envs[self.variant]
    uses = env['all_dependencies']

    # pure Python files (just installed)
    self(
        features = 'py',
            name = 'code_aster_py',
          source = get_srcs('**/*.py',
                            excl=['Cata/Commons/*.py', 'Cata/Commands/*.py']),
    install_from = '.',
    install_path = osp.join(env.ASTERLIBDIR, 'code_aster'),
    )

    build_eficas_catalog(self)

    build_libaster_dependencies(self)
    self.add_group()
    build_wrappers_on_libaster(self)


def build_libaster_dependencies(self):
    get_srcs = self.path.get_src().ant_glob
    env = self.all_envs[self.variant]
    uses = env['all_dependencies']

    # Core & Supervis are used by libaster (must be named 'lib*')
    # bibcxx is using the generated includes
    for cymodule in get_srcs('Supervis/**/*.pyx'):
        path = cymodule.abspath()
        modname = osp.splitext(osp.basename(path))[0]
        dirname = osp.basename(osp.dirname(path))

        self(
            features = 'cxx cxxshlib pyext',
              source = cymodule,
                name = modname,
              target = osp.join(dirname, modname),
        install_path = osp.join(env.ASTERLIBDIR, 'code_aster', dirname),
        )
        # 'use' in bibc would add 'lib' to the target name (that already
        # contains 'lib'), that's why we define another product CODE_ASTER_CORE
        # to deal dependencies.
        env.append_value('LIB_CODE_ASTER_CORE', [modname.replace('lib', '')])
        env.append_unique('LIBPATH_CODE_ASTER_CORE', [osp.join('code_aster', dirname)])

def build_wrappers_on_libaster(self):
    get_srcs = self.path.get_src().ant_glob
    env = self.all_envs[self.variant]
    uses = env['all_dependencies']

    # Wrappers on C++ objects uses libaster
    wrapper = get_srcs('**/*.pyx', excl=['Core/**/*.pyx', 'Supervis/**/*.pyx'])
    for cymodule in wrapper:
        path = cymodule.abspath()
        modname = osp.splitext(osp.basename(path))[0]
        dirname = osp.basename(osp.dirname(path))

        self(
            features = 'cxx cxxshlib pyext',
              source = cymodule,
              target = osp.join(dirname, modname),
                 use = ['asterlib', 'CODE_ASTER_CORE'],
        install_path = osp.join(env.ASTERLIBDIR, 'code_aster', dirname),
        )

###############################################################################
def build_eficas_catalog(self):
    get_srcs = self.path.get_src().ant_glob
    env = self.all_envs[self.variant]
    # catalog for eficas
    mfront_capy = self.path.get_bld().parent.find_or_declare('c_mfront_official.py')
    self(
        features = 'catapy',
            name = 'cata_py',
          source = get_srcs('Cata/Commons/accas.capy') \
                 + get_srcs('Cata/Commons/allco.capy') \
                 + [mfront_capy] \
                 + get_srcs('Cata/Commons/*.py',
                            excl=['Cata/Commons/__init__.py', 'Cata/Commons/ops.py']) \
                 + get_srcs('Cata/Commands/*.py',
                            excl='Cata/Commands/__init__.py'),
          target = 'cata.py',
    install_from = '.',
    install_path = osp.join(env.ASTERLIBDIR, 'code_aster'),
    )
    self(
        features = 'py',
            name = 'ops_py',
          source = get_srcs('Cata/Commons/ops.py'),
          target = 'ops.py',
    install_path = osp.join(env.ASTERLIBDIR, 'eficas'),
    )

# manage extension
@TaskGen.extension('.capy')
def capy(self, node):
    pass

@TaskGen.feature('catapy')
def make_cata(self):
    """Create the cata.py"""
    target = self.bld.bldnode.make_node(self.target)
    init = self.bld.bldnode.make_node('__init__.py')
    init.write('# init')
    init.sig = Utils.h_file(init.abspath())
    tsk = self.create_task('make_capy', src=self.source, tgt=target)
    # self.process_py(target): not use because would use `install_from` argument
    def inst_py(ctx):
        install_pyfile(self, target, '../eficas')
        install_pyfile(self, init, '../eficas')
    self.bld.add_post_fun(inst_py)

def install_pyfile(self, node, subdir):
    """See waflib/Tools/python.py: Just ignore install_from argument"""
    from_node = node.parent
    dest = osp.join(self.install_path, subdir, node.path_from(from_node))
    tsk = self.bld.install_as(dest, node, postpone=False)

class make_capy(Task.Task):
    color   = 'PINK'
    ext_out = ['.py']
    banned = 'code_aster.Cata'

    def run(self):
        """Merge capy files to cata.py and install it."""
        # doing merge in python as it is multi-plateform
        target = self.outputs[0]
        cata = []
        for node in self.inputs:
            with open(node.abspath()) as subfid:
                lines = [line for line in subfid.read().splitlines() \
                         if self.banned not in line]
                cata.extend(lines)
        with open(target.abspath(), 'w') as fid:
            fid.write(os.linesep.join(cata))
        target.sig = Utils.h_file(target.abspath())
