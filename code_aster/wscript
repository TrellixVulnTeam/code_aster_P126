# coding=utf-8

# Copyright (C) 1991 - 2015  EDF R&D                www.code-aster.org
#
# This file is part of Code_Aster.
#
# Code_Aster is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# Code_Aster is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Code_Aster.  If not, see <http://www.gnu.org/licenses/>.

import os.path as osp

from waflib import TaskGen, Configure, Logs, Utils, Errors


def options(self):
    self.load('cython')

def configure(self):
    self.load('cython')

def build(self):
    get_srcs = self.path.get_src().ant_glob
    env = self.all_envs[self.variant]
    uses = env['all_dependencies']

    # pure Python files (just installed)
    self(
        features = 'py',
            name = 'code_aster_py',
          source = get_srcs('**/*.py'),
    install_from = '.',
    install_path = osp.join(env.ASTERLIBDIR, 'code_aster'),
    )
    
    build_libaster_dependencies(self)
    build_wrappers_on_libaster(self)


def build_libaster_dependencies(self):
    get_srcs = self.path.get_src().ant_glob
    env = self.all_envs[self.variant]
    uses = env['all_dependencies']

    # Core & Supervis are used by libaster (must be named 'lib*')
    # bibcxx is using the generated includes
    for cymodule in get_srcs('Core/**/*.pyx') + get_srcs('Supervis/**/*.pyx'):
        path = cymodule.abspath()
        modname = osp.splitext(osp.basename(path))[0]
        dirname = osp.basename(osp.dirname(path))

        self(
            features = 'cxx cxxshlib pyext',
              source = cymodule,
                name = modname,
              target = osp.join(dirname, modname),
        install_path = osp.join(env.ASTERLIBDIR, 'code_aster', dirname),
        )
        # 'use' in bibc would add 'lib' to the target name (that already
        # contains 'lib'), that's why we define another product CODE_ASTER_CORE
        # to deal dependencies.
        env.append_value('LIB_CODE_ASTER_CORE', [modname.replace('lib', '')])
        env.append_unique('LIBPATH_CODE_ASTER_CORE', [osp.join('code_aster', dirname)])

def build_wrappers_on_libaster(self):
    get_srcs = self.path.get_src().ant_glob
    env = self.all_envs[self.variant]
    uses = env['all_dependencies']

    # Wrappers on C++ objects uses libaster
    wrapper = get_srcs('**/*.pyx', excl=['Core/**/*.pyx', 'Supervis/**/*.pyx'])
    for cymodule in wrapper:
        path = cymodule.abspath()
        modname = osp.splitext(osp.basename(path))[0]
        dirname = osp.basename(osp.dirname(path))

        self(
            features = 'cxx cxxshlib pyext',
              source = cymodule,
              target = osp.join(dirname, modname),
                 use = ['asterlib'],
        install_path = osp.join(env.ASTERLIBDIR, 'code_aster', dirname),
        )
